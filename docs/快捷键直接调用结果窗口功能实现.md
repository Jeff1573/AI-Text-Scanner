# 快捷键直接调用结果窗口功能实现

## 概述

本文档记录了修改快捷键 `CommandOrControl+Shift+T` 的行为，使其直接调用 `createResultWindow` 函数的实现过程。

## 修改目标

1. 快捷键 `CommandOrControl+Shift+T` 直接调用 `createResultWindow` 函数
2. 获取剪贴板内容作为默认输入
3. 移除原有的中间处理步骤（IPC 消息传递）
4. 保持快捷键的其他行为不变

## 实现方案

### 1. 添加剪贴板支持

在 `main/main.ts` 中添加 clipboard 模块导入：

```typescript
import {
  app,
  BrowserWindow,
  desktopCapturer,
  session,
  ipcMain,
  screen,
  globalShortcut,
  Tray,
  Menu,
  nativeImage,
  clipboard, // 新增
} from "electron";
```

### 2. 修改托盘菜单快捷键行为

原有实现：
```typescript
{
  label: '快捷翻译',
  accelerator: 'CmdOrCtrl+Shift+T',
  click: () => {
    if (!mainWindow) {
      createWindow();
    }
    if (mainWindow && !mainWindow.isDestroyed()) {
      mainWindow.webContents.send('open-result-page');
    }
  }
}
```

修改后：
```typescript
{
  label: '快捷翻译',
  accelerator: 'CmdOrCtrl+Shift+T',
  click: () => {
    console.log('托盘菜单快捷翻译被点击');
    // 获取剪贴板内容作为默认内容
    const clipboardText = clipboard.readText();
    // 如果剪贴板有内容，将其作为原文，否则使用空内容
    const defaultContent = clipboardText 
      ? JSON.stringify({ original: clipboardText, translated: "" })
      : '{"original": "", "translated": ""}';
    createResultWindow(defaultContent);
  }
}
```

### 3. 修改全局快捷键注册

原有实现：
```typescript
const ret1 = globalShortcut.register('CommandOrControl+Shift+T', () => {
  console.log('全局快捷键被触发，准备打开ResultPage');
  
  if (!mainWindow) {
    createWindow();
  }
  
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('open-result-page');
    mainWindow.setAlwaysOnTop(true)
  }
});
```

修改后：
```typescript
const ret1 = globalShortcut.register('CommandOrControl+Shift+T', () => {
  console.log('全局快捷键被触发，准备直接打开结果窗口');
  
  // 获取剪贴板内容作为默认内容
  const clipboardText = clipboard.readText();
  // 如果剪贴板有内容，将其作为原文，否则使用空内容
  const defaultContent = clipboardText 
    ? JSON.stringify({ original: clipboardText, translated: "" })
    : '{"original": "", "translated": ""}';
  
  // 直接调用 createResultWindow 函数
  createResultWindow(defaultContent);
});
```

### 4. 添加剪贴板 API 支持

为了支持渲染进程访问剪贴板，添加了新的 IPC 处理器：

```typescript
// 新增：获取剪贴板内容的 IPC handler
ipcMain.handle("get-clipboard-text", async () => {
  try {
    const text = clipboard.readText();
    return { success: true, text };
  } catch (error) {
    return { success: false, error: error.message, text: "" };
  }
});
```

在 `main/preload.ts` 中暴露 API：
```typescript
// 新增：获取剪贴板内容
getClipboardText: () => ipcRenderer.invoke('get-clipboard-text'),
```

在 TypeScript 类型定义中添加：
```typescript
getClipboardText: () => Promise<{ success: boolean; text: string; error?: string }>;
```

## 核心改进

### 1. 直接调用机制

- **之前**：快捷键 → IPC 消息 → 渲染进程路由跳转 → 显示结果页面
- **现在**：快捷键 → 直接调用 `createResultWindow` → 创建独立结果窗口

### 2. 剪贴板集成

- 自动读取剪贴板内容作为默认输入
- 智能处理剪贴板内容格式（转换为 JSON 格式）
- 空剪贴板时提供默认空内容

### 3. 数据格式处理

确保传递给 `createResultWindow` 的数据格式符合 `ResultPage` 组件的期望：

```typescript
const defaultContent = clipboardText 
  ? JSON.stringify({ original: clipboardText, translated: "" })
  : '{"original": "", "translated": ""}';
```

## 优势

1. **响应速度更快**：直接创建窗口，无需 IPC 通信和路由跳转
2. **用户体验更好**：自动获取剪贴板内容，减少手动输入
3. **代码更简洁**：移除中间处理步骤，逻辑更直接
4. **独立窗口**：结果窗口独立于主窗口，可以置顶显示

## 兼容性

- 保留了原有的 IPC 监听器，确保其他功能不受影响
- `createResultWindow` 函数保持原有接口不变
- 新增的剪贴板 API 为可选功能，不影响现有代码

## 测试建议

1. 测试快捷键 `CommandOrControl+Shift+T` 是否能正确打开结果窗口
2. 测试剪贴板内容是否能正确显示在结果窗口中
3. 测试空剪贴板时是否显示空内容
4. 测试托盘菜单中的快捷翻译功能
5. 确保其他功能（截图识别等）不受影响
